"""
This type stub file was generated by pyright.
"""

"""
Miscellaneous Helpers for NetworkX.

These are not imported into the base networkx namespace but
can be accessed, for example, as

>>> import networkx
>>> networkx.utils.make_list_of_ints({1, 2, 3})
[1, 2, 3]
>>> networkx.utils.arbitrary_element({5, 1, 7})  # doctest: +SKIP
1
"""
__all__ = ["is_string_like", "iterable", "empty_generator", "flatten", "make_list_of_ints", "is_list_of_ints", "make_str", "generate_unique_node", "default_opener", "dict_to_numpy_array", "dict_to_numpy_array1", "dict_to_numpy_array2", "is_iterator", "arbitrary_element", "consume", "pairwise", "groups", "to_tuple", "create_random_state", "create_py_random_state", "PythonRandomInterface", "nodes_equal", "edges_equal", "graphs_equal"]
def is_string_like(obj): # -> bool:
    """Check if obj is string.

    .. deprecated:: 2.6
        This is deprecated and will be removed in NetworkX v3.0.
    """
    ...

def iterable(obj): # -> bool:
    """Return True if obj is iterable with a well-defined len().

    .. deprecated:: 2.6
        This is deprecated and will be removed in NetworkX v3.0.
    """
    ...

def empty_generator(): # -> Generator[Never, None, None]:
    """Return a generator with no members.

    .. deprecated:: 2.6
    """
    ...

def flatten(obj, result=...): # -> str | tuple[Unknown, ...]:
    """Return flattened version of (possibly nested) iterable object."""
    ...

def make_list_of_ints(sequence): # -> list[Unknown]:
    """Return list of ints from sequence of integral numbers.

    All elements of the sequence must satisfy int(element) == element
    or a ValueError is raised. Sequence is iterated through once.

    If sequence is a list, the non-int values are replaced with ints.
    So, no new list is created
    """
    ...

def is_list_of_ints(intlist): # -> bool:
    """Return True if list is a list of ints.

    .. deprecated:: 2.6
        This is deprecated and will be removed in NetworkX v3.0.
    """
    ...

def make_str(x): # -> str:
    """Returns the string representation of t.

    .. deprecated:: 2.6
        This is deprecated and will be removed in NetworkX v3.0.
    """
    ...

def generate_unique_node(): # -> str:
    """Generate a unique node label.

    .. deprecated:: 2.6
        This is deprecated and will be removed in NetworkX v3.0.
    """
    ...

def default_opener(filename): # -> None:
    """Opens `filename` using system's default program.

    .. deprecated:: 2.6
       default_opener is deprecated and will be removed in version 3.0.
       Consider an image processing library to open images, such as Pillow::

           from PIL import Image
           Image.open(filename).show()

    Parameters
    ----------
    filename : str
        The path of the file to be opened.

    """
    ...

def dict_to_numpy_array(d, mapping=...):
    """Convert a dictionary of dictionaries to a numpy array
    with optional mapping."""
    ...

def dict_to_numpy_array2(d, mapping=...):
    """Convert a dict of dicts to a 2d numpy array with optional mapping.

    .. deprecated:: 2.8

       dict_to_numpy_array2 is deprecated and will be removed in networkx 3.0.
       Use `dict_to_numpy_array` instead.
    """
    ...

def dict_to_numpy_array1(d, mapping=...):
    """Convert a dict of numbers to a 1d numpy array with optional mapping.

    .. deprecated:: 2.8

       dict_to_numpy_array1 is deprecated and will be removed in networkx 3.0.
       Use dict_to_numpy_array instead.
    """
    ...

def is_iterator(obj): # -> bool:
    """Returns True if and only if the given object is an iterator object.

    .. deprecated:: 2.6.0
        Deprecated in favor of ``isinstance(obj, collections.abc.Iterator)``
    """
    ...

def arbitrary_element(iterable):
    """Returns an arbitrary element of `iterable` without removing it.

    This is most useful for "peeking" at an arbitrary element of a set,
    but can be used for any list, dictionary, etc., as well.

    Parameters
    ----------
    iterable : `abc.collections.Iterable` instance
        Any object that implements ``__iter__``, e.g. set, dict, list, tuple,
        etc.

    Returns
    -------
    The object that results from ``next(iter(iterable))``

    Raises
    ------
    ValueError
        If `iterable` is an iterator (because the current implementation of
        this function would consume an element from the iterator).

    Examples
    --------
    Arbitrary elements from common Iterable objects:

    >>> nx.utils.arbitrary_element([1, 2, 3])  # list
    1
    >>> nx.utils.arbitrary_element((1, 2, 3))  # tuple
    1
    >>> nx.utils.arbitrary_element({1, 2, 3})  # set
    1
    >>> d = {k: v for k, v in zip([1, 2, 3], [3, 2, 1])}
    >>> nx.utils.arbitrary_element(d)  # dict_keys
    1
    >>> nx.utils.arbitrary_element(d.values())   # dict values
    3

    `str` is also an Iterable:

    >>> nx.utils.arbitrary_element("hello")
    'h'

    :exc:`ValueError` is raised if `iterable` is an iterator:

    >>> iterator = iter([1, 2, 3])  # Iterator, *not* Iterable
    >>> nx.utils.arbitrary_element(iterator)
    Traceback (most recent call last):
        ...
    ValueError: cannot return an arbitrary item from an iterator

    Notes
    -----
    This function does not return a *random* element. If `iterable` is
    ordered, sequential calls will return the same value::

        >>> l = [1, 2, 3]
        >>> nx.utils.arbitrary_element(l)
        1
        >>> nx.utils.arbitrary_element(l)
        1

    """
    ...

def consume(iterator): # -> None:
    """Consume the iterator entirely.

    .. deprecated:: 2.6
        This is deprecated and will be removed in NetworkX v3.0.
    """
    ...

def pairwise(iterable, cyclic=...): # -> zip[tuple[Unknown, None]] | zip[tuple[Unknown, Unknown]]:
    "s -> (s0, s1), (s1, s2), (s2, s3), ..."
    ...

def groups(many_to_one): # -> dict[Unknown, set[Unknown]]:
    """Converts a many-to-one mapping into a one-to-many mapping.

    `many_to_one` must be a dictionary whose keys and values are all
    :term:`hashable`.

    The return value is a dictionary mapping values from `many_to_one`
    to sets of keys from `many_to_one` that have that value.

    Examples
    --------
    >>> from networkx.utils import groups
    >>> many_to_one = {"a": 1, "b": 1, "c": 2, "d": 3, "e": 3}
    >>> groups(many_to_one)  # doctest: +SKIP
    {1: {'a', 'b'}, 2: {'c'}, 3: {'e', 'd'}}
    """
    ...

def to_tuple(x): # -> tuple[Unknown, ...]:
    """Converts lists to tuples.

    .. deprecated:: 2.8

       to_tuple is deprecated and will be removed in NetworkX 3.0.

    Examples
    --------
    >>> from networkx.utils import to_tuple
    >>> a_list = [1, 2, [1, 4]]
    >>> to_tuple(a_list)
    (1, 2, (1, 4))
    """
    ...

def create_random_state(random_state=...):
    """Returns a numpy.random.RandomState or numpy.random.Generator instance
    depending on input.

    Parameters
    ----------
    random_state : int or NumPy RandomState or Generator instance, optional (default=None)
        If int, return a numpy.random.RandomState instance set with seed=int.
        if `numpy.random.RandomState` instance, return it.
        if `numpy.random.Generator` instance, return it.
        if None or numpy.random, return the global random number generator used
        by numpy.random.
    """
    ...

class PythonRandomInterface:
    def __init__(self, rng=...) -> None:
        ...
    
    def random(self):
        ...
    
    def uniform(self, a, b):
        ...
    
    def randrange(self, a, b=...):
        ...
    
    def choice(self, seq):
        ...
    
    def gauss(self, mu, sigma):
        ...
    
    def shuffle(self, seq):
        ...
    
    def sample(self, seq, k):
        ...
    
    def randint(self, a, b):
        ...
    
    def expovariate(self, scale):
        ...
    
    def paretovariate(self, shape):
        ...
    


def create_py_random_state(random_state=...): # -> PythonRandomInterface | Random:
    """Returns a random.Random instance depending on input.

    Parameters
    ----------
    random_state : int or random number generator or None (default=None)
        If int, return a random.Random instance set with seed=int.
        if random.Random instance, return it.
        if None or the `random` package, return the global random number
        generator used by `random`.
        if np.random package, return the global numpy random number
        generator wrapped in a PythonRandomInterface class.
        if np.random.RandomState or np.random.Generator instance, return it
        wrapped in PythonRandomInterface
        if a PythonRandomInterface instance, return it
    """
    ...

def nodes_equal(nodes1, nodes2): # -> bool:
    """Check if nodes are equal.

    Equality here means equal as Python objects.
    Node data must match if included.
    The order of nodes is not relevant.

    Parameters
    ----------
    nodes1, nodes2 : iterables of nodes, or (node, datadict) tuples

    Returns
    -------
    bool
        True if nodes are equal, False otherwise.
    """
    ...

def edges_equal(edges1, edges2): # -> bool:
    """Check if edges are equal.

    Equality here means equal as Python objects.
    Edge data must match if included.
    The order of the edges is not relevant.

    Parameters
    ----------
    edges1, edges2 : iterables of with u, v nodes as
        edge tuples (u, v), or
        edge tuples with data dicts (u, v, d), or
        edge tuples with keys and data dicts (u, v, k, d)

    Returns
    -------
    bool
        True if edges are equal, False otherwise.
    """
    ...

def graphs_equal(graph1, graph2):
    """Check if graphs are equal.

    Equality here means equal as Python objects (not isomorphism).
    Node, edge and graph data must match.

    Parameters
    ----------
    graph1, graph2 : graph

    Returns
    -------
    bool
        True if graphs are equal, False otherwise.
    """
    ...

