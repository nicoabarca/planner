from datetime import datetime
from fastapi import HTTPException
from prisma import Json
from prisma.models import Plan as DbPlan
from prisma.types import PlanCreateInput
from pydantic import BaseModel
import pydantic
from ..plan.plan import ValidatablePlan
from typing import Union

_plan_model_fields = list(DbPlan.__fields__.keys())
# automatic definition of low detail to avoid hardcoding attributes
# something like: ['id', 'created_at', 'updated_at', 'name', 'is_favorite', 'user_rut']
_low_detail_attributes = [
    attr for attr in _plan_model_fields if attr not in ["validatable_plan"]
]


class PlanView(BaseModel):
    """
    Detailed, typed view of a plan in the database.
    The only difference between this type and `DbPlan` (ie. the plan schema) is that
    the type of `PlanView.validatable_plan` is `ValidatablePlan`, while the type of
    `Plan.validatable_plan` is `Json`.
    """

    id: str
    created_at: datetime
    updated_at: datetime
    name: str
    is_favorite: bool
    user_rut: str
    validatable_plan: ValidatablePlan

    @staticmethod
    def from_db(db: DbPlan) -> "PlanView":
        return PlanView(
            id=db.id,
            created_at=db.created_at,
            updated_at=db.updated_at,
            name=db.name,
            is_favorite=db.is_favorite,
            user_rut=db.user_rut,
            validatable_plan=pydantic.parse_raw_as(
                ValidatablePlan, db.validatable_plan
            ),
        )


class LowDetailPlanView(BaseModel):
    """
    Lighter version of the PlanView model.
    This should only contain the required attributes to show the user their plans list
    """

    id: str
    created_at: datetime
    updated_at: datetime
    name: str
    is_favorite: bool

    @staticmethod
    def from_db(db: DbPlan) -> "LowDetailPlanView":
        return LowDetailPlanView(
            id=db.id,
            created_at=db.created_at,
            updated_at=db.updated_at,
            name=db.name,
            is_favorite=db.is_favorite,
        )


async def authorize_plan_access(user_rut: str, plan_id: str) -> DbPlan:
    plan = await DbPlan.prisma().find_unique(where={"id": plan_id})
    if not plan or plan.user_rut != user_rut:
        raise HTTPException(status_code=404, detail="Plan not found in user storage")
    return plan


async def store_plan(plan_name: str, user_rut: str, plan: ValidatablePlan) -> PlanView:
    # TODO: set max 50 plans per user

    data = {
        "name": plan_name,
        "user_rut": user_rut,
        "is_favorite": False,
        "validatable_plan": Json(plan.json()),
    }

    # all model attributes are being used (except for the first three autogenerated)
    assert set(data.keys()) == set(_plan_model_fields[3:])

    plan_data = PlanCreateInput(**data)  # type: ignore
    stored_plan = await DbPlan.prisma().create(data=plan_data)

    return PlanView.from_db(stored_plan)


async def get_plan_details(user_rut: str, plan_id: str) -> PlanView:
    plan = await authorize_plan_access(user_rut, plan_id)
    return PlanView.from_db(plan)


async def get_user_plans(user_rut: str) -> list[LowDetailPlanView]:
    # NOTE: this query interpolation is safe because the value to interpolate is
    # internally managed. Otherwise, do not interpolate without input sanitization!
    plans = await DbPlan.prisma().query_raw(
        f"""
        SELECT {", ".join(_low_detail_attributes)}
        FROM "Plan"
        WHERE user_rut = $1
        """,
        user_rut,
    )

    return list(map(lambda plan: LowDetailPlanView.from_db(plan), plans))


async def modify_validatable_plan(
    user_rut: str, plan_id: str, new_plan: ValidatablePlan
) -> PlanView:
    await authorize_plan_access(user_rut, plan_id)

    updated_plan = await DbPlan.prisma().update(
        where={"id": plan_id}, data={"validatable_plan": Json(new_plan.json())}
    )
    # Must be true because access was authorized
    assert updated_plan is not None

    return PlanView.from_db(updated_plan)


async def modify_plan_metadata(
    user_rut: str,
    plan_id: str,
    set_name: Union[str, None],
    set_favorite: Union[bool, None],
) -> PlanView:
    await authorize_plan_access(user_rut, plan_id)

    if set_name is not None:
        return await rename_plan(plan_id=plan_id, new_name=set_name)

    if set_favorite is not None:
        return await set_favorite_plan(
            user_rut=user_rut, plan_id=plan_id, favorite=set_favorite
        )

    raise HTTPException(
        status_code=400, detail="Must specify the attribute of Plan to update"
    )


async def rename_plan(plan_id: str, new_name: str):
    updated_plan = await DbPlan.prisma().update(
        where={
            "id": plan_id,
        },
        data={
            "name": new_name,
        },
    )

    # Must be true because access was authorized
    assert updated_plan is not None

    return PlanView.from_db(updated_plan)


async def set_favorite_plan(user_rut: str, plan_id: str, favorite: bool):
    # NOTE: with the current algorithm there cannot be more than one favorite plan
    # per user originated by this method. But there is no validation of uniqueness in
    # the DB.

    plan = await DbPlan.prisma().find_unique(where={"id": plan_id})
    if plan is None:
        raise HTTPException(status_code=404, detail="Plan not found in user storage")

    if plan.is_favorite == favorite:
        # nothing to be done
        return PlanView.from_db(plan)

    # Transaction (atomic)
    await DbPlan.prisma().query_raw("BEGIN")
    await DbPlan.prisma().query_raw(
        """
        UPDATE "Plan" SET is_favorite = FALSE
            WHERE user_rut = $1
        """,
        user_rut,
    )
    await DbPlan.prisma().query_raw(
        """
        UPDATE "Plan" SET is_favorite = $1
            WHERE id = $2
        """,
        favorite,
        plan_id,
    )
    await DbPlan.prisma().query_raw("COMMIT")

    updated_plan = await DbPlan.prisma().find_unique(where={"id": plan_id})

    # Must be true because access was authorized
    assert updated_plan is not None

    return PlanView.from_db(updated_plan)


async def remove_plan(user_rut: str, plan_id: str) -> PlanView:
    await authorize_plan_access(user_rut, plan_id)

    deleted_plan = await DbPlan.prisma().delete(where={"id": plan_id})
    # Must be true because access was authorized
    assert deleted_plan is not None

    return PlanView.from_db(deleted_plan)
